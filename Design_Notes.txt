Design Process:
1. Create first UML based on requirements and just basic instincts. (23/01/2022)
2. Go over padbas of PingPong and MAS to see whay I can improve upon and learn from the previous Exercise.
3. Identify whether Component separation is clear and good, then identify the C_O_R_E.
4. Recreate UML with new patterns and abstractions (as per method of Shahar).
5. Submit to Segel, async await WaitForSegelResponse();
-----------------------------------------------------------------------------------------------------------------------------------
Tasks:
             - Maybe go over Cancellation Tokens
             - Maybe go over Channels
-----------------------------------------------------------------------------------------------------------------------------------
First Thoughts:
             - Basically create Whatsapp logic BTS (BL), then add Console and Blazor UI implementations.
             - Splitting the UI from the BL, keeping coupling to a minimum, and focusing on SRP will 
	       be the biggest challenges to doing this Exercise Correctly I think.
-----------------------------------------------------------------------------------------------------------------------------------
Priorities:
LEVEL 1:
             - TCP-Based
             - Text Notifications
             - Global chat where all clients participate
             - On Connect/Disconnect of client a notification is sent
LEVEL 2:
             - Private Messaging
             - Chat History
             - File Sending
LEVEL 3:
             - Group Chats
             - Blazor UI Implementation for Clients
LEVEL 4:
             - Not really understanding the requirements yet (Hebrew-wise).
-----------------------------------------------------------------------------------------------------------------------------------
The flow of the program:
	- A Server holding a TcpListener listens for TcpClient connections
	- On connection, it passes them to a CommunicationRouter
	- The CommunicationRouter "subscribes" (using Tasks and ConcurrentBag or Events) 
	  the client to the GlobalChat
	- The GlobalChat holds a history of all messages that pass through
	- CommunicationRouter has options to create PrivateMessage and GroupChats
	- The concept of multiple chats can be handled by either the CommunicationRouter getting the specific 
	  message and passing it on to the correct channel, or (just an interesting idea, not sure how smart)
	  each channel is passed through its own port, so the CommunicationRouter handles which port the user is 
	  connected to, simplifying a lot of logic.
	- Each ChatChannel holds a IList of all TcpClients connected, and on each message recieve it echoes back to all clients
 -----------------------------------------------------------------------------------------------------------------------------------
REDESIGN STAGE:
Reason:
The previous design had many flaws, especially for later stages of the program, and wouldn't be very expandable with the UI
New Design:
	- Client connects to server
	- Server gives him to the router
	- The router attaches him to the global chat
	- The router holds a dictionary for each client of which chat he is currently in
	- When a user sends a message, it goes through the router which sends it to the specific chat
	- The chat logs the message to its backlog list of messages
	- The message is sent through the router to each user who is in its list AND also is currently in that chat
	- The user gets the chat printed to his message board
	- When the user joins a new chat, he automatically gets the backlog
-----------------------------------------------------------------------------------------------------------------------------------
Current Server Design is good imo, but theres still one big unsolved puzzle piece:
How does the Client get the ability to affect (use) the Router's functions such as Chat Creation?
	Honestly, this should be done using HTTP and Request-Response, but since we're using Tcp, I guess a defacto 
	Request-Response will be the right way to go.
-----------------------------------------------------------------------------------------------------------------------------------
Finished Stage 1!
Awesome! That went really well because of the good design I did ahead of time.
Stage 2 is a bit more complex because it has to do with the strange group creation request on the client side, gotta consider how to do it.
Will begin with chat history and file sending.
File sending -> Will require to update the Send and Receive methods in TcpCommunicator to use buffers so that ethernet max limit isn't reached.
		Will use similar code to my PingPong from last week.