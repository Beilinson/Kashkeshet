Design Process:
1. Create first UML based on requirements and just basic instincts. (23/01/2022)
2. Go over padbas of PingPong and MAS to see whay I can improve upon and learn from the previous Exercise.
3. Identify whether Component separation is clear and good, then identify the C_O_R_E.
4. Recreate UML with new patterns and abstractions (as per method of Shahar).
5. Submit to Segel, async await WaitForSegelResponse();
-----------------------------------------------------------------------------------------------------------------------------------
Tasks:
             - Maybe go over Cancellation Tokens
             - Maybe go over Channels
-----------------------------------------------------------------------------------------------------------------------------------
First Thoughts:
             - Basically create Whatsapp logic BTS (BL), then add Console and Blazor UI implementations.
             - Splitting the UI from the BL, keeping coupling to a minimum, and focusing on SRP will 
	       be the biggest challenges to doing this Exercise Correctly I think.
-----------------------------------------------------------------------------------------------------------------------------------
Priorities:
LEVEL 1:
             - TCP-Based
             - Text Notifications
             - Global chat where all clients participate
             - On Connect/Disconnect of client a notification is sent
LEVEL 2:
             - Private Messaging
             - Chat History
             - File Sending
LEVEL 3:
             - Group Chats
	     - Logger
             - Blazor UI Implementation for Clients
LEVEL 4:
             - Not really understanding the requirements yet (Hebrew-wise).
-----------------------------------------------------------------------------------------------------------------------------------
The flow of the program:
	- A Server holding a TcpListener listens for TcpClient connections
	- On connection, it passes them to a CommunicationRouter
	- The CommunicationRouter "subscribes" (using Tasks and ConcurrentBag or Events) 
	  the client to the GlobalChat
	- The GlobalChat holds a history of all messages that pass through
	- CommunicationRouter has options to create PrivateMessage and GroupChats
	- The concept of multiple chats can be handled by either the CommunicationRouter getting the specific 
	  message and passing it on to the correct channel, or (just an interesting idea, not sure how smart)
	  each channel is passed through its own port, so the CommunicationRouter handles which port the user is 
	  connected to, simplifying a lot of logic.
	- Each ChatChannel holds a IList of all TcpClients connected, and on each message recieve it echoes back to all clients
 -----------------------------------------------------------------------------------------------------------------------------------
REDESIGN STAGE:
Reason:
The previous design had many flaws, especially for later stages of the program, and wouldn't be very expandable with the UI
New Design:
	- Client connects to server
	- Server gives him to the router
	- The router attaches him to the global chat
	- The router holds a dictionary for each client of which chat he is currently in
	- When a user sends a message, it goes through the router which sends it to the specific chat
	- The chat logs the message to its backlog list of messages
	- The message is sent through the router to each user who is in its list AND also is currently in that chat
	- The user gets the chat printed to his message board
	- When the user joins a new chat, he automatically gets the backlog
-----------------------------------------------------------------------------------------------------------------------------------
Current Server Design is good imo, but theres still one big unsolved puzzle piece:
How does the Client get the ability to affect (use) the Router's functions such as Chat Creation?
	Honestly, this should be done using HTTP and Request-Response, but since we're using Tcp, I guess a defacto 
	Request-Response will be the right way to go.
-----------------------------------------------------------------------------------------------------------------------------------
Finished Stage 1!
Awesome! That went really well because of the good design I did ahead of time.
Stage 2 is a bit more complex because it has to do with the strange group creation request on the client side, gotta consider how to do it.
Will begin with chat history and file sending.
File sending -> Will require to update the Send and Receive methods in TcpCommunicator to use buffers so that ethernet max limit isn't reached.
		Will use similar code to my PingPong from last week.
-----------------------------------------------------------------------------------------------------------------------------------
Well so far I managed to implement File sending without touching the TcpCommunicator code so thats awesome, 
but there is probably a limit of 1500kb file size that I can't work around.

The file handling process in the Sender and Receiver should be taken out into an abstraction held by the ChatClient,
but other than that all good!

Private (and group) chats ability is already existing, but IClientRequest needs to be implemented now, which will be quite complex
I expect. Gotta think about the Design a bit before I move forward.
-----------------------------------------------------------------------------------------------------------------------------------
Also had some unrelated ideas:
1. I could add sudo-"e2e" for messages sent in the server and from the clients. Cool idea!
2. All the chats on the server-side should be stored in DB on disk, MUCH better if I'd want to make the server NSSM and restartable.
-----------------------------------------------------------------------------------------------------------------------------------
Design additional thoughts:
1. 	The specific use of TcpListener and TcpClient from within the ChatServer might be breaking DIP, 
	maybe have a ISocketClient and ISocketListener DTO's?
2. 	Same with the ChatRouter using TcpCommunicator specifically within, needs to be substituted with DIP,
	and ICommunicator might need to become an abstract class.
3.	IClientRequests and the ChatRouter need to have some Protocol (an agreed upon set of rules) for communicating request-responses
	IMO set it up in Common with an Enum/Dictionary for request and response types
-----------------------------------------------------------------------------------------------------------------------------------
Explaining the program:
The general design is this:
(BL)
Common:
	Responsible for everything in common between the two Client/Server BL projects, including:
	- Communicators (ICommunicator similarly to PingPong padbas)
		(ChatProtocol is an enum meant for request-response type behavior across the Client-Server model, with each
		 having a factory created set of actions based on the desired behavior.)
	- Logging (Logger singleton)
	- UI (I/O abstractions)
	- User (UserData DTO for multitude of communication/storage purposes)
	- FileTypes (IFile + Generic implementation for storing important file data to transfer across netStream)
	- Loaders (IFileLoader + Implementation for loading provided Files)
	- Factories (Any place in the code where a DTO or other needs to be created at run-time uses a factory abstraction
ClientSide:
	- Abstractions (IClient is meant to hold and activate IClientRunnables with its ICommunicator)
	- ConsoleImplementation:
		1. ChatClient is the main client implementation used in the ClientHost (Console implementation). 
		   It runs a receiver and sender in parallel.
		2. SimpleClientReceiver/Sender are IClientRunnables that are meant for Message notifications only
		3. ClientRequestSender/ResponseReceiver are IClientRunnables that use a ChatProtocol dict to process 
		   sent/received notifications/requests
BlazorClient:
	- The groundworks for the components to be used in the web client
ServerSide:
	- Core (Abstractions of:
		- IServer is the actual server that runs and listens for incoming connections.
		- Incoming connections are sent to the ICommunicationRouter, which runs tasks for each connection
		  and handles any incoming requests by its ChatProtocol dict
		- IRoutable is the interface for "Chats"
		- IMessageHistory is the interface for storing Messages in the server long-term.
		- RoutableCollection is a DTO storing all the connected Users (ICommunicators), all IRoutables (chats),
		  and which user is active in which current IRoutable
	- ChatImplementation:
		- Other than the obvious which act as described above,
		- ChatRouter stores the GlobalRoutableController for routing messages to the desired route, it offloads it 
		  to the ChatProtocol response dict.
(Factories)
	- Both Client and Server factories have specific factories for ChatProtocol 
	  Request(Client)/Response(Server)/FinalOutput(Client) handling.
	- Rest of the factories are self explanatory
(Application)
ClientHost:
	- Bootstrapper and program for the ConsoleImplementation of a chat-client.
ServerHost:
	- Bootstrapper and program for the implementation of a ChatServer (runs on console).
Blazor: 
	- The future implementation for the Web-client